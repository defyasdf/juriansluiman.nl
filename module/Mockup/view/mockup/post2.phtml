<?php
    $this->headTitle()->set('Using Zend Framework service managers in your application')
?>

<article class="blog-article" itemprop="blogPosts" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="cf">
        <time datetime="2011-11-06T13:42:04+01:00" pubdate itemprop="datePublished" content="2011-11-06"  class="blog-article-publishdate">november 2011</time>
        <h1 itemprop="name" class="blog-article-title"><a href="" itemprop="url">Using Zend Framework service managers in your application</a></h1>
    </header>

    <p>Zend Framework 2 uses a ServiceManager component (in short, SM) to easily apply inversion of control. I notice there are good resources about the background of service managers (I recommend <a rel="external" href="http://blog.evan.pro/introduction-to-the-zend-framework-2-servicemanager" target="_blank">this blog post from Evan</a> or <a rel="external" href="http://zendblog.shinymayhem.com/2012/09/using-servicemanager-as-inversion-of.html" target="_blank">this post from Reese Wilson</a>) but many people still have problems to tune the SM to their needs. In this post I will try to explain the reason why the framework uses multiple service managers and how you can use these. I address the following topics:</p>
    <ol>
        <li>What are the different service managers?</li>
        <li>For what reason are different managers used?</li>
        <li>How does the service locator relate to the service manager?</li>
        <li>How can you define services for all those service managers?</li>
        <li>How can you retrieve services from one manager inside a second one?</li>
    </ol>

    <p>Service managers are used in Zend Framework 2 at a variety of places, but these four are the most important ones:</p>

    <ol>
        <li>General application services ("root service manager" or "main service manager")</li>
        <li>Controllers</li>
        <li>Controller plugins</li>
        <li>View helpers</li>
    </ol>

    <p>Every group has its own service manager with the benefit you can have one service key for different services. Perhaps you know there is a "url" view helper, but also a "url" controller plugin. This would be really hard to achieve when you have one service manager where the "url" key needs to be put into context. With multiple managers, you can easily keep track of them both.</p>

    <p>There is also the aspect of security. You might have a route where you have a parameter for the controller. By typing in a special url, the service manager tries to instantiate that service for you. If you don't care about security too much, you might accidentally instantiate all kinds of objects by requesting special urls.</p>

    <h2>Difference between the manager and the locator</h2>

    <p>Many people ask questions about the difference between the service locator and the service manager. The service locator (or SL) is an interface which is very slim:</p>

    <pre><code>namespace Zend\ServiceManager;

interface ServiceLocatorInterface
{
    public function get($name);
    public function has($name);
}</code></pre>

    <p>The service manager is a service locator implementation. By default the Zend Framework 2 implementation of the SL is the SM. Throughout the framework you see sometimes <code>getServiceLocator()</code> methods and sometimes <code>getServiceManager()</code> methods. For <code>getServiceLocator()</code>, you get the SL returned and for <code>getServiceManager()</code> you explicitly ask for the SM implementation.</p>

    <p>It is not a big difference at this moment, since both methods will return the same object. However you can choose to have a different SL implementation. You keep yourself to the SL contract, but several zf2 components still need the specific SM implementation.</p>

    <h2>Configuration of the service manager</h2>

    <p>The service managers can be configured in two ways: the module class can return the SM config and the module configuration file (config/module.config.php in most cases) can return SM config. Both result in the exact same service config so it is only a matter of taste where you would like to put the config.</p>

    <p>You can add services in either of these ways:</p>

    <pre><code><span class="comment">/**
 * With the module class
 */</span>
namespace MyModule;

class Module
{
  public function getServiceConfig()
  {
    return array(
      'invokables' => array(
        'my-foo' => 'MyModule\Foo\Bar',
      ),
    );
  }
}</code></pre>

    <pre><code><span class="comment">/**
 * With the module config
 */</span>
return array(
  'service_manager' => array(
    'invokables' => array(
      'my-foo' => 'MyModule\Foo\Bar'
    ),
  ),
);</code></pre>

    <p>As you see, for both methods the content of the array is the same. This is true for all four types of service managers. With the module class method, you can <a rel="external" href="http://en.wikipedia.org/wiki/Duck_typing" target="_blank">duck type</a> the method and the config will be loaded. You can also play by the contract and add an interface where you are more strict in the declaration of this method. With an interface applied, your module class could look like this:</p>

    <pre><code>namespace MyModule;

use Zend\ModuleManager\Feature\ServiceProviderInterface;

class Module implements ServiceProviderInterface
{
  public function getServiceConfig()
  {
    return array(
      'invokables' => array(
        'my-foo' => 'MyModule\Foo\Bar',
      ),
    );
  }
}</code></pre>

    <p>For all four service managers, you can add a key to your module config or add a method to your module class. For the later, you can choose to duck type with the method or add a <code>Zend\ModuleManager\Feature\*</code> interface. The below table shows the link between all of them:</p>

    <table width="100%">
    <tbody>
    <tr>
    <td style="width: 30%;"><em>Manager</em></td>
    <td>Application services</td>
    </tr>
    <tr>
    <td><em>Manager class</em></td>
    <td>Zend\ServiceManager\ServiceManager</td>
    </tr>
    <tr>
    <td><em>Config key</em></td>
    <td>service_manager</td>
    </tr>
    <tr>
    <td><em>Module method</em></td>
    <td>getServiceConfig()</td>
    </tr>
    <tr>
    <td><em>Module interface</em></td>
    <td>ServiceProviderInterface</td>
    </tr>
    </tbody>
    </table>
    <table style="width: 100%;">
    <tbody>
    <tr>
    <td style="width: 30%;"><em>Manager</em></td>
    <td>Controllers</td>
    </tr>
    <tr>
    <td><em>Manager class</em></td>
    <td>Zend\Mvc\Controller\ControllerManager</td>
    </tr>
    <tr>
    <td><em>Config key</em></td>
    <td>controllers</td>
    </tr>
    <tr>
    <td><em>Module method</em></td>
    <td>getControllerConfig()</td>
    </tr>
    <tr>
    <td><em>Module interface</em></td>
    <td>ControllerProviderInterface</td>
    </tr>
    </tbody>
    </table>
    <table style="width: 100%;">
    <tbody>
    <tr>
    <td style="width: 30%;"><em>Manager</em></td>
    <td>Controller plugins</td>
    </tr>
    <tr>
    <td><em>Manager class</em></td>
    <td>Zend\Mvc\Controller\PluginManager</td>
    </tr>
    <tr>
    <td><em>Config key</em></td>
    <td>controller_plugins</td>
    </tr>
    <tr>
    <td><em>Module method</em></td>
    <td>getControllerPluginConfig()</td>
    </tr>
    <tr>
    <td><em>Module interface</em></td>
    <td>ControllerPluginProviderInterface</td>
    </tr>
    </tbody>
    </table>
    <table style="width: 100%;">
    <tbody>
    <tr>
    <td style="width: 30%;"><em>Manager</em></td>
    <td>View helpers</td>
    </tr>
    <tr>
    <td><em>Manager class</em></td>
    <td>Zend\View\HelperPluginManager</td>
    </tr>
    <tr>
    <td><em>Config key</em></td>
    <td>view_helpers</td>
    </tr>
    <tr>
    <td><em>Module method</em></td>
    <td>getViewHelperConfig()</td>
    </tr>
    <tr>
    <td><em>Module interface</em></td>
    <td>ViewHelperProviderInterface</td>
    </tr>
    </tbody>
    </table>

    <h3>Be careful</h3>

    <p>There is one catch you need to be aware of. As <a rel="external" href="http://blog.evan.pro/introduction-to-the-zend-framework-2-servicemanager" target="_blank">Evan explains</a>, there are two options for a factory. You can have a closure or a string pointing to a class. This class must implement the <code>FactoryInterface</code>. The factories can be places inside the module config and in the module class.</p>

    <p>If you have a closure <strong>and</strong> place this inside the module.config.php, then you will get a problem. All the module configurations can be cached as a big merged config. The problem with php is that closures cannot be serialized. So you either have to use factory classes in your module.config.php or you must use the <code>getServiceConfig()</code> method and alike to use closures.</p>

    <h2>The root manager versus the others</h2>

    <p>The name root (or also "main") is often used in discussions on IRC for example, but it not really related to any naming of the Zend Framework 2 code base. The name probably comes from the idea the <code>ServiceManager</code> holds all main services and the other managers are more specific for one type of services. The name "root" suggests there is a relation between some managers. And guess? Yes, there is a link!</p>

    <p>Imagine you have a controller where you want to inject a cache storage instance into. The controller has it's factory inside the controller service manager. The cache is a service in the root service manager. How do you get the cache service inside your controller factory? That's where the link comes from. The controller, controller plugin and view helper service managers are an implementation of <code>AbstractPluginManager</code>. This class has a method <code>getServiceLocator()</code> which returns the root service locator. This makes it possible to travel around between the different managers:</p>

    <pre><code>use MyModule\Controller;

return array(
  'controllers' =>
    'factories' => array(
      'MyModule\Controller\Foo' => function($sm) {
        $controller = new Controller\FooController;

        $cache = $sm->getServiceLocator()->get('my-cache');
        $controller->setCache($cache);

        return $controller;
      },
    ),
  ),
);</code></pre>

    <p>Here the cache service is located in the root service locator and with <code>$sm-&gt;getServiceLocator()</code> you can retrieve services from that one.</p>

    <p>It becomes even more fun if you know that the controller plugin manager and the view helper manager are registered as services in the root service locator. If there is a service where you need to inject a runtime object into a view helper, you can easily do that too. For example the url view helper has the router injected, which is required to assemble urls from a route name.</p>

    <p>You can get the controller plugin manager with the key "ControllerPluginManager" from the root SM. The view helper manager is registered with "ViewHelperManager" in the SM. You can get a plugin for example like this:</p>

    <pre><code>use MyModule\Service;

return array(
  'service_manager' =>
    'factories' => array(
      'MyModule\Service\Foo' => function($sm) {
        $service = new Service\Foo;

        $plugin = $sm->get('ViewHelperManager')->plugin('my-plugin');
        $service->setPlugin($plugin);

        return $service;
      },
    ),
  ),
);</code></pre>

    <h2>Peering service managers</h2>

    <p>The concept of peering service managers is quite easy to understand. There is a way for the controller plugin and view helper service managers to load the service from the root service manager without using <code>$sm-&gt;getServiceLocator()</code>. This concept is peering, which basically means that the controller plugin service manager tries to fetch the service from the root service manager when it fails to load its own service.</p>

    <p>So if you look at above example, you can skip in some occasions the <code>getServiceLocator()</code> method and directly fetch the service. This <strong>only holds for controller plugins and view helpers</strong>. The reason is obvious. There is a controller service manager for security reasons: you might accidentally create an instance of an object just because you request a special URL. You completely knock down this barrier when you allow the controller service manager to get services by peering. However, for controller plugins and view helpers it could still be worth working with peering:</p>

    <pre><code>use MyModule\Controller\Plugin;

return array(
  'controller_plugins' =>
    'factories' => array(
      'MyModule\Controller\Plugin\Foo' => function($sm) {
        $plugin = new Plugin\Foo;

        $cache = $sm->get('my-cache');
        $plugin->setCache($cache);

        return $plugin;
      },
    ),
  ),
);</code></pre>

    <p>The benefit you have is that you simply can ignore <code>getServiceLocator()</code> for plugins and helpers. It makes your code perhaps a bit easier to read. You read my sceptical concerns between the lines: peering is not directly easy to grasp. In above example, the <code>$sm</code> does not hold the service "my-cache", but if you try to get it, you get the cache back. Document this kind of factories very well, because else you will get trouble later on!</p>

    <h2>Personal preference</h2>

    <p>In my personal opinion, I like the strict usage of interfaces in my module. I always apply the <code>Zend\ModuleManager\Feature</code> interfaces. I also like the style where all the services are combined into one config file with closures as factories. This helps to scroll through all service keys from one module, without other clutter of route config (from the module config) or autoload config and bootstrap logic (from the module class).</p>

    <p>Usually I have besides the module.config.php also a service.config.php in the config/ directory. And I include that file just like the module configuration. The module classes look often like this:</p>

    <pre><code>namespace MyModule;

use Zend\Loader;
use Zend\ModuleManager\Feature;
use Zend\EventManager\EventInterface;

class Module implements
    Feature\AutoloaderProviderInterface,
    Feature\ConfigProviderInterface,
    Feature\ServiceProviderInterface,
    Feature\BootstrapListenerInterface
{
    public function getAutoloaderConfig()
    {
        return array(
            Loader\AutoloaderFactory::STANDARD_AUTOLOADER => array(
                Loader\StandardAutoloader::LOAD_NS => array(
                    __NAMESPACE__ => __DIR__ . '/src/' . __NAMESPACE__,
                ),
            ),
        );
    }

    public function getConfig()
    {
        return include __DIR__ . '/config/module.config.php';
    }

    public function getServiceConfig()
    {
        return include __DIR__ . '/config/service.config.php';
    }

    public function onBootstrap(EventInterface $e)
    {
        // Some logic
    }
}</code></pre>

    <p>In the module.config.php I provide my normal config, in the service.config.php all services are grouped together. An example for this type of setup is shown in <a rel="external" href="https://github.com/ensemble/EnsembleKernel" target="_blank">EnsembleKernel</a> where the service.config.php <a rel="external" href="https://github.com/ensemble/EnsembleKernel/blob/master/config/services.config.php" target="_blank">looks like this</a>. But of course there are many other possibilities where you can tune the setup to your likes.﻿</p>

    <h2>Other design test blocks</h2>

    <blockquote>
        This is a small quote from an unknown source
    </blockquote>

    <p>Lorem ipsum bla bla.</p>

    <blockquote>
        <p>The service managers can be configured in two ways: the module class can return the SM config and the module configuration file (config/module.config.php in most cases) can return SM config. Both result in the exact same service config so it is only a matter of taste where you would like to put the config.</p>
        <p>As you see, for both methods the content of the array is the same. This is true for all four types of service managers. With the module class method, you can <a rel="external" href="http://en.wikipedia.org/wiki/Duck_typing" target="_blank">duck type</a> the method and the config will be loaded. You can also play by the contract and add an interface where you are more strict in the declaration of this method. With an interface applied, your module class could look like this:</p>
        <p><cite>Some source here</cite></p>
    </blockquote>

</article>